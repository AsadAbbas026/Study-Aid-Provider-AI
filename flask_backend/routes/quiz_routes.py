from flask import Blueprint, request, jsonify
from models.extensions import db
from models.quiz_model import Quiz, QuizQuestion, QuestionTypeEnum, Answer, QuizResult
from models.notes_model import Note
from services.quiz_service import generate_quiz_from_notes, evaluate_answer
from datetime import datetime
import json

quiz_bp = Blueprint('quiz', __name__)

@quiz_bp.route('/generate_quiz', methods=['POST'])
def generate_quiz():
    data = request.get_json()
    print(f"[DEBUG] Received data for quiz generation: {data}")
    
    user_id = data.get('user_id')
    note_id = data.get('notes_id')
    
    if not user_id or not note_id:
        print("[DEBUG] Missing user_id or notes_id")
        return jsonify({"error": "user_id and notes_id are required"}), 400
    note_id = int(note_id)
    # Step 1: Fetch note
    note = Note.query.filter_by(id=note_id, user_id=user_id).first()
    if not note:
        print(f"[DEBUG] Note not found for user_id={user_id}, note_id={note_id}")
        return jsonify({"error": "Note not found"}), 404

    print(f"[DEBUG] Fetched Note: {note.title}")

    # Step 2: Generate quiz questions using AI
    questions = generate_quiz_from_notes(note.content)
    print(f"[DEBUG] AI generated {len(questions) if questions else 0} questions")

    if not questions or len(questions) == 0:
        print("[DEBUG] No questions generated by AI")
        return jsonify({"error": "No questions generated"}), 500

    try:
        # Step 3: Create a new Quiz entry
        quiz = Quiz(
            user_id=user_id,
            title=f"Quiz from Note {note.title}",
            note_id=note_id,
            created_at=datetime.utcnow()
        )
        db.session.add(quiz)
        db.session.flush()
        print(f"[DEBUG] Created Quiz entry with id={quiz.id}")

        # Step 4: Add QuizQuestion entries
        for i, q in enumerate(questions):
            question_type = q.get('type', 'self_explanatory')
            print(f"[DEBUG] Adding Question {i + 1}: Type={question_type}")

            quiz_question = QuizQuestion(
                quiz_id=quiz.id,
                question_text=q.get('question'),
                options=q.get('options') if question_type == 'multiple_choice' else None,
                answer=q.get('answer'),  # << FIXED HERE
                ai_answer=q.get('answer'),  # Optional: Only if needed
                explanation=q.get('explanation', None),
                question_type=QuestionTypeEnum(question_type)
            )

            db.session.add(quiz_question)

        db.session.commit()
        print(f"[DEBUG] Quiz committed successfully with {len(questions)} questions")

        return jsonify({
            "message": "Quiz created successfully",
            "quiz": {
                "id": quiz.id,
                "title": note.title,
                "desc": note.content,
                "created_at": quiz.created_at.isoformat(),
                "questions": [
                    {
                        "id": q.id,
                        "question": q.question_text,
                        "answer": q.answer,
                        "type": q.question_type.value,
                    }
                    for q in quiz.questions
                ]
            }
        }), 200

    except Exception as e:
        db.session.rollback()
        print(f"[ERROR] Exception while saving quiz: {str(e)}")
        return jsonify({"error": str(e)}), 500


@quiz_bp.route('/get_quizzes', methods=["POST"])
def get_quizzes():
    data = request.get_json()
    print(f"[DEBUG] Received data for get_quizzes: {data}")

    user_id = data.get('user_id')

    if not user_id:
        print("[DEBUG] quiz_id not provided")
        return jsonify({"error": "quiz_id is required"}), 400

    quizzes = Quiz.query.filter_by(user_id=user_id).all()
    print(f"[DEBUG] Found {len(quizzes)} quizzes with id={user_id}")

    if not quizzes:
        print("[DEBUG] No quizzes found")
        return jsonify({"message": "No quizzes found"}), 404

    quiz_list = []
    for quiz in quizzes:
        quiz_data = {
            "id": quiz.id,
            "title": quiz.title,
            "created_at": quiz.created_at.strftime("%Y-%m-%d %H:%M:%S"),
            "note_id": quiz.note_id
        }
        print(f"[DEBUG] Appending quiz: {quiz_data}")
        quiz_list.append(quiz_data)
    return jsonify({"quizzes": quiz_list}), 200


@quiz_bp.route('/get_quiz_questions', methods=["POST"])
def get_quiz_questions():
    data = request.get_json()
    print("[DEBUG] Raw incoming data:", data)

    quiz_id = data.get('quiz_id')
    print("[DEBUG] Received quiz_id:", quiz_id)

    if not quiz_id:
        print("[ERROR] quiz_id is missing in the request.")
        return jsonify({"error": "quiz_id is required"}), 400

    quiz = Quiz.query.filter_by(id=quiz_id).first()
    print("[DEBUG] Quiz object fetched from DB:", quiz)

    if not quiz:
        print("[ERROR] No quiz found with the given quiz_id.")
        return jsonify({"error": "Quiz not found"}), 404

    print(f"[DEBUG] Total questions found for quiz {quiz_id}: {len(quiz.questions)}")

    questions_data = []
    for i, q in enumerate(quiz.questions):
        print(f"[DEBUG] Processing Question {i + 1}: ID={q.id}, Text='{q.question_text}'")
        question_data = {
            "id": q.id,
            "question": q.question_text,
            "type": q.question_type.value,
            "options": q.options if q.question_type == QuestionTypeEnum.MULTIPLE_CHOICE else None,
            "answer": q.answer
        }
        print(f"[DEBUG] Question Data {i + 1}: {question_data}")
        questions_data.append(question_data)

    print("[DEBUG] Final questions data to send:", questions_data)
    return jsonify({"questions": questions_data}), 200

@quiz_bp.route('/submit_quiz', methods=["POST"])
def submit_quiz():
    data = request.get_json()
    print(f"Received data: {data}")

    user_id = data.get('user_id')
    quiz_id = data.get('quiz_id')
    user_answers = data.get('answers')
    duration_seconds = data.get('duration_seconds')

    score = 0
    total_questions = 0
    feedbacks = []

    quiz = Quiz.query.filter_by(id=quiz_id).first()
    if not quiz:
        return jsonify({"error": "Quiz not found"}), 404
    print(f"Quiz found: {quiz}")

    quiz_questions = QuizQuestion.query.filter_by(quiz_id=quiz_id).all()
    question_dict = {q.id: q for q in quiz_questions}
    print(f"Quiz Questions: {list(question_dict.keys())}")

    for user_answer in user_answers:
        question_id = int(user_answer.get('question_id'))
        user_answer_text = user_answer.get('answer_text')
        question = question_dict.get(question_id)

        if not question:
            print(f"Question ID {question_id} not found. Skipping.")
            continue

        expected_answer = question.answer.lower()
        is_correct = False
        explanation = "No explanation available."
        feedback = "No feedback available."

        print(f"Evaluating Question ID: {question.id}, Type: {question.question_type}, User Answer: {user_answer_text}")

        result = evaluate_answer(question.question_text, expected_answer, user_answer_text)

        if isinstance(result, dict):
            text_data = result.get("text", {})

            feedback = text_data.get("feedback", feedback)
            explanation = text_data.get("explanation", explanation)
            status = text_data.get("status")

        if question.question_type in [QuestionTypeEnum.MULTIPLE_CHOICE, QuestionTypeEnum.TRUE_FALSE]:
            is_correct = user_answer_text.strip().lower() == expected_answer
        elif question.question_type == QuestionTypeEnum.SELF_EXPLANATORY:
            is_correct = status == "Correct"

        feedback_info = {
            "question_text": str(question.question_text),
            "user_answer": str(user_answer_text),
            "correct_answer": str(question.answer),
            "status": "Correct" if is_correct else "Incorrect",
            "explanation": str(explanation) if explanation else "No explanation available.",
            "feedback": str(feedback)
        }

        feedbacks.append(feedback_info)
        print(f"Feedback: {feedback_info}")

        total_questions += 1
        if is_correct:
            score += 1

        answer = Answer(
            question_id=question.id,
            quiz_id=quiz_id,
            user_id=user_id,
            answer_text=user_answer_text,
            is_correct=is_correct
        )
        db.session.add(answer)

    result = QuizResult(
        quiz_id=quiz_id,
        user_id=user_id,
        score=score,
        total_questions=total_questions,
        correct_answers=score,
        duration_seconds=duration_seconds
    )
    db.session.add(result)
    db.session.commit()

    print(f"Final Score: {score}/{total_questions}")
    return jsonify({"feedbacks": feedbacks})

@quiz_bp.route('/delete_quiz', methods=['DELETE'])
def delete_quiz():
    data = request.get_json()
    print(f"[DEBUG] Received data for deletion: {data}")  # Debug incoming request data

    quiz_id = data.get('quiz_id')
    user_id = data.get('user_id')

    if not quiz_id or not user_id:
        print("[DEBUG] Missing quiz_id or user_id in request.")
        return jsonify({'message': 'Quiz ID and User ID are required!'}), 400

    print(f"[DEBUG] Attempting to delete Quiz ID: {quiz_id} for User ID: {user_id}")
    quiz = Quiz.query.filter_by(id=quiz_id, user_id=user_id).first()

    if not quiz:
        print(f"[DEBUG] No quiz found with ID: {quiz_id} for User ID: {user_id}")
        return jsonify({'message': 'Quiz not found!'}), 404

    print(f"[DEBUG] Deleting quiz: {quiz}")
    db.session.delete(quiz)
    db.session.commit()
    print(f"[DEBUG] Quiz deleted successfully!")

    return jsonify({'message': 'Quiz deleted successfully!'}), 200
